---
alwaysApply: true
---

# Error Handling Standards

## Error Classes

Use standardized error classes from `_shared/error.ts`:

```typescript
import { 
  APIError,
  AuthenticationError,
  AuthorizationError,
  NotFoundError,
  ValidationError,
  DatabaseError 
} from './_shared/error.ts';
```

## Error Class Definitions

### APIError (Base)
```typescript
throw new APIError('Custom message', 400, 'ERROR_CODE');
```
- Base class for all API errors
- Custom status code and error code
- **Use only when specific error type doesn't fit**

### AuthenticationError (401)
```typescript
throw new AuthenticationError(); // Default: 'ไม่ได้รับอนุญาต'
throw new AuthenticationError('Token หมดอายุ');
```
- User not authenticated
- Invalid/missing token
- Token expired

### AuthorizationError (403)
```typescript
throw new AuthorizationError(); // Default: 'ไม่มีสิทธิ์เข้าถึง'
throw new AuthorizationError('ต้องการสิทธิ์ระดับ 2 ขึ้นไป');
```
- User authenticated but lacks permission
- Insufficient level
- Resource access denied

### NotFoundError (404)
```typescript
throw new NotFoundError(); // Default: 'ไม่พบข้อมูล'
throw new NotFoundError('ไม่พบพนักงาน');
```
- Resource not found
- Invalid ID
- Deleted resource

### ValidationError (400)
```typescript
throw new ValidationError('กรุณาระบุชื่อ');
throw new ValidationError('รูปแบบอีเมลไม่ถูกต้อง');
```
- Invalid input data
- Missing required fields
- Format validation failures

### DatabaseError (500)
```typescript
throw new DatabaseError(); // Default: 'เกิดข้อผิดพลาดในการเข้าถึงข้อมูล'
throw new DatabaseError('ไม่สามารถบันทึกข้อมูลได้');
```
- Database connection issues
- Query failures
- Constraint violations (when not caught specifically)

## Error Handling Pattern

### In Main Entry Point (index.ts)

```typescript
Deno.serve(async (req) => {
  const corsResponse = handleCORS(req);
  if (corsResponse) return corsResponse;

  try {
    const { employee } = await authenticate(req);
    
    // Routing logic
    
    return error('Not found', 404);
  } catch (err) {
    // ALWAYS use handleError
    const { message, statusCode } = handleError(err);
    return error(message, statusCode);
  }
});
```

### In Handlers

```typescript
export async function create(req: Request, employee: Employee) {
  // Check permissions
  await requireMinLevel(employee, 1);

  // Parse and validate
  const body = await req.json();
  if (!body.name) {
    throw new ValidationError('กรุณาระบุชื่อ');
  }

  // Call service
  const result = await ResourceService.create(body);
  
  return success(result);
}
```

**Note**: Handlers should NOT catch errors. Let them bubble up to the main handler.

### In Service Layer

```typescript
export class ResourceService {
  static async getById(id: string): Promise<Resource> {
    const supabase = createServiceClient();
    
    const { data, error } = await supabase
      .from('resources')
      .select('*')
      .eq('id', id)
      .single();

    if (error) {
      throw new DatabaseError('ไม่สามารถดึงข้อมูลได้');
    }

    if (!data) {
      throw new NotFoundError('ไม่พบข้อมูล');
    }

    return data;
  }

  static async create(resourceData: Record<string, unknown>): Promise<Resource> {
    const supabase = createServiceClient();
    const sanitized = this.sanitizeResourceData(resourceData);

    const { data, error } = await supabase
      .from('resources')
      .insert(sanitized)
      .select()
      .single();

    if (error) {
      // Check for specific errors
      if (error.message.includes('duplicate key')) {
        throw new ValidationError('ข้อมูลซ้ำในระบบ');
      }
      throw new DatabaseError('ไม่สามารถสร้างข้อมูลได้');
    }

    return data;
  }

  static async delete(id: string): Promise<void> {
    const supabase = createServiceClient();

    const { error } = await supabase
      .from('resources')
      .delete()
      .eq('id', id);

    if (error) {
      if (error.message.includes('foreign key')) {
        throw new ValidationError('มีข้อมูลอ้างอิงที่ใช้งานอยู่ ไม่สามารถลบได้');
      }
      throw new DatabaseError('ไม่สามารถลบข้อมูลได้');
    }
  }
}
```

## Common Validation Patterns

### Required Fields
```typescript
if (!body.field_name) {
  throw new ValidationError('กรุณาระบุ{field_name_thai}');
}
```

### UUID Format
```typescript
const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
if (!uuidRegex.test(id)) {
  throw new ValidationError('รูปแบบ ID ไม่ถูกต้อง');
}
```

### Email Format
```typescript
const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
if (!emailRegex.test(email)) {
  throw new ValidationError('รูปแบบอีเมลไม่ถูกต้อง');
}
```

### Date Format
```typescript
if (isNaN(Date.parse(date_string))) {
  throw new ValidationError('รูปแบบวันที่ไม่ถูกต้อง');
}
```

### Number Range
```typescript
if (level < 0 || level > 10) {
  throw new ValidationError('ระดับต้องอยู่ระหว่าง 0-10');
}
```

## handleError Function

The `handleError` function in `_shared/error.ts` automatically converts errors to appropriate HTTP responses:

```typescript
export function handleError(err: unknown): { message: string; statusCode: number } {
  if (err instanceof APIError) {
    return {
      message: err.message,
      statusCode: err.statusCode,
    };
  }
  
  if (err instanceof Error) {
    // Check for common database errors
    if (err.message.includes('JWT')) {
      return { message: 'Session หมดอายุกรุณาเข้าใช้งานใหม่', statusCode: 401 };
    }
    if (err.message.includes('duplicate key')) {
      return { message: 'ข้อมูลซ้ำ', statusCode: 409 };
    }
    if (err.message.includes('foreign key')) {
      return { message: 'มีข้อมูลอ้างอิงที่ใช้งานอยู่ ไม่สามารถลบได้', statusCode: 409 };
    }
    return { message: err.message, statusCode: 500 };
  }
  
  return { message: 'เกิดข้อผิดพลาดที่ไม่ทราบสาเหตุ', statusCode: 500 };
}
```

## Error Response Format

All errors return JSON in this format:

```json
{
  "error": "error message in Thai"
}
```

HTTP status code is set appropriately:
- 400: Bad Request (validation errors)
- 401: Unauthorized (authentication errors)
- 403: Forbidden (authorization errors)
- 404: Not Found
- 409: Conflict (duplicate, foreign key)
- 500: Internal Server Error
- 501: Not Implemented

## Logging Errors

For development/debugging only:

```typescript
try {
  // operation
} catch (err) {
  console.error('[api-resource] Error:', err);
  throw err; // Re-throw after logging
}
```

**Remove console.error in production code** or use structured logging.

## Testing Error Cases

Always test:
1. Missing authentication
2. Insufficient permissions
3. Invalid input data
4. Resource not found
5. Database constraint violations
6. Malformed requests

## Error Message Language

**ALWAYS use Thai language** for user-facing error messages:

✅ **CORRECT**:
```typescript
throw new ValidationError('กรุณาระบุชื่อ');
throw new NotFoundError('ไม่พบข้อมูลพนักงาน');
throw new AuthorizationError('ไม่มีสิทธิ์เข้าถึง');
```

❌ **WRONG**:
```typescript
throw new ValidationError('Please enter name');
throw new NotFoundError('Employee not found');
throw new AuthorizationError('Access denied');
```

## When to Use Which Error

| Scenario | Error Type | Status |
|----------|-----------|--------|
| No auth token | AuthenticationError | 401 |
| Invalid token | AuthenticationError | 401 |
| Not enough permission | AuthorizationError | 403 |
| Resource doesn't exist | NotFoundError | 404 |
| Missing required field | ValidationError | 400 |
| Invalid format | ValidationError | 400 |
| Duplicate entry | ValidationError | 400 |
| Foreign key violation | ValidationError | 400 |
| Database connection issue | DatabaseError | 500 |
| Unknown query error | DatabaseError | 500 |
| Route not found | error('Not found', 404) | 404 |
