# Migration Review Workflow

Step-by-step guide to safely handle migrations generated by `supabase db pull` to prevent "relation does not exist" errors.

---

## The Problem

When `supabase db pull` generates a migration, it may create `DROP POLICY` statements that reference tables created in other migrations. This causes errors when migrations run in chronological order.

---

## Step-by-Step Workflow

### Step 1: Run `db pull`

```bash
supabase db pull
```

This creates a new migration file like: `supabase/migrations/YYYYMMDDHHMMSS_remote_schema.sql`

### Step 2: Review the Generated Migration

**Check for DROP statements:**

```bash
# On Windows PowerShell
Select-String -Path "supabase/migrations/YYYYMMDDHHMMSS_remote_schema.sql" -Pattern "DROP POLICY"

# Or open the file and search for "DROP POLICY"
```

**Look for:**
- `DROP POLICY` statements
- References to tables that might not exist yet
- Any statements that depend on tables being created first

### Step 3: Check Which Migration Creates Those Tables

```bash
# Find which migration creates the tables
grep -r "CREATE TABLE.*app_configuration" supabase/migrations/
grep -r "CREATE TABLE.*appointments" supabase/migrations/
# etc.
```

**Compare timestamps:**
- If the table is created in a migration with a **later timestamp** than the DROP statement, you have a problem
- Example: Table created in `20251116211708_*.sql` but DROP in `20251116170915_*.sql` ❌

### Step 4: Fix DROP Statements

**For each DROP POLICY statement, make it conditional:**

#### Option A: Simple Conditional (Single Policy)

Replace:
```sql
DROP POLICY "delete_policy" ON "public"."app_configuration";
```

With:
```sql
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables 
             WHERE table_schema = 'public' 
             AND table_name = 'app_configuration') THEN
    DROP POLICY IF EXISTS "delete_policy" ON "public"."app_configuration";
  END IF;
END $$;
```

#### Option B: Helper Function (Multiple Policies)

If you have many policies to drop, use the helper function pattern:

**At the start of the migration:**
```sql
-- Helper function to safely drop policies if table exists
CREATE OR REPLACE FUNCTION drop_policies_if_table_exists(
  table_name text,
  policy_names text[]
) RETURNS void AS $$
DECLARE
  policy_name text;  -- ⚠️ IMPORTANT: Must declare loop variable
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables 
             WHERE table_schema = 'public' 
             AND table_name = drop_policies_if_table_exists.table_name) THEN
    FOREACH policy_name IN ARRAY policy_names
    LOOP
      EXECUTE format('DROP POLICY IF EXISTS %I ON public.%I', 
                     policy_name, 
                     drop_policies_if_table_exists.table_name);
    END LOOP;
  END IF;
END;
$$ LANGUAGE plpgsql;
```

**⚠️ Important:** The `DECLARE` section is required for the FOREACH loop variable!

**Replace multiple DROP statements:**
```sql
-- Instead of:
DROP POLICY "delete_policy" ON "public"."app_configuration";
DROP POLICY "insert_policy" ON "public"."app_configuration";
DROP POLICY "select_policy" ON "public"."app_configuration";
DROP POLICY "update_policy" ON "public"."app_configuration";

-- Use:
SELECT drop_policies_if_table_exists('app_configuration', 
  ARRAY['delete_policy', 'insert_policy', 'select_policy', 'update_policy']);
```

**At the end of the migration:**
```sql
-- Clean up helper function
DROP FUNCTION IF EXISTS drop_policies_if_table_exists(text, text[]);
```

### Step 5: Test Locally

**Always test before pushing:**

```bash
# Reset local database (applies all migrations in order)
supabase db reset
```

**If it fails:**
- Check the error message
- Fix the migration
- Test again

**If it succeeds:**
- ✅ Migration is safe to push

### Step 6: Commit and Push

```bash
# Review changes
git diff supabase/migrations/

# Commit
git add supabase/migrations/YYYYMMDDHHMMSS_remote_schema.sql
git commit -m "chore: sync remote schema with conditional DROP statements"

# Push to remote
supabase db push
```

---

## Quick Reference: What to Look For

### ✅ Safe Migration

```sql
-- Creating tables
CREATE TABLE IF NOT EXISTS public.app_configuration (...);

-- Creating policies (after table exists)
CREATE POLICY "select_policy" ON "public"."app_configuration" ...;
```

### ⚠️ Potentially Problematic

```sql
-- Dropping policies without checking if table exists
DROP POLICY "delete_policy" ON "public"."app_configuration";
```

### ✅ Fixed Version

```sql
-- Conditional drop (safe)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables 
             WHERE table_schema = 'public' 
             AND table_name = 'app_configuration') THEN
    DROP POLICY IF EXISTS "delete_policy" ON "public"."app_configuration";
  END IF;
END $$;
```

---

## Common Tables That Need Conditional Drops

Based on your project, these tables are often created in later migrations:

- `app_configuration`
- `appointments`
- `companies`
- `contacts`
- `employees`
- `feature`
- `leave_balances`, `leave_requests`, `leave_types`
- `poll_options`, `poll_votes`, `polls`
- `roles`, `sites`
- `ticket_employees`, `ticket_statuses`, `tickets`
- `work_result_document_pages`, `work_result_documents`, `work_result_photos`, `work_results`, `work_types`

**If you see DROP statements for any of these, make them conditional!**

---

## Automation: Quick Fix Script

You can create a PowerShell script to help identify problematic DROP statements:

```powershell
# find-problematic-drops.ps1
$migrationFile = "supabase/migrations/20251116170915_remote_schema.sql"

# Find all DROP POLICY statements
$drops = Select-String -Path $migrationFile -Pattern 'DROP POLICY.*ON "public"\."(\w+)"'

Write-Host "Found DROP POLICY statements on these tables:"
$drops | ForEach-Object {
    $tableName = $_.Matches.Groups[1].Value
    Write-Host "  - $tableName"
}

Write-Host "`nCheck if these tables are created in later migrations!"
```

---

## Summary Checklist

When you run `supabase db pull`:

1. ✅ **Review** the generated migration file
2. ✅ **Search** for `DROP POLICY` statements
3. ✅ **Check** if referenced tables exist in earlier migrations
4. ✅ **Fix** DROP statements to be conditional
5. ✅ **Test** locally with `supabase db reset`
6. ✅ **Commit** and push

**Remember:** It's better to spend 5 minutes reviewing than 30 minutes debugging!

---

## Example: Complete Fix

**Before (Problematic):**
```sql
drop extension if exists "pg_net";

drop policy "delete_policy" on "public"."app_configuration";
drop policy "insert_policy" on "public"."app_configuration";
drop policy "select_policy" on "public"."app_configuration";
drop policy "update_policy" on "public"."app_configuration";

drop policy "delete_policy" on "public"."appointments";
-- ... more drops
```

**After (Fixed):**
```sql
drop extension if exists "pg_net";

-- Helper function to safely drop policies if table exists
CREATE OR REPLACE FUNCTION drop_policies_if_table_exists(
  table_name text,
  policy_names text[]
) RETURNS void AS $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables 
             WHERE table_schema = 'public' 
             AND table_name = drop_policies_if_table_exists.table_name) THEN
    FOREACH policy_name IN ARRAY policy_names
    LOOP
      EXECUTE format('DROP POLICY IF EXISTS %I ON public.%I', 
                     policy_name, 
                     drop_policies_if_table_exists.table_name);
    END LOOP;
  END IF;
END;
$$ LANGUAGE plpgsql;

-- Drop app_configuration policies only if table exists
SELECT drop_policies_if_table_exists('app_configuration', 
  ARRAY['delete_policy', 'insert_policy', 'select_policy', 'update_policy']);

-- Drop appointments policies only if table exists
SELECT drop_policies_if_table_exists('appointments', 
  ARRAY['delete_policy', 'insert_policy', 'select_policy', 'update_policy']);

-- ... more tables

-- Clean up helper function
DROP FUNCTION IF EXISTS drop_policies_if_table_exists(text, text[]);
```

This pattern ensures migrations work regardless of execution order!

